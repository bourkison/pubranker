drop policy "authenticated users can create unique reviews" on "public"."reviews";

drop function if exists "public"."get_pub"(input_id integer, dist_long double precision, dist_lat double precision);

drop function if exists "public"."nearby_pubs"(order_lat double precision, order_long double precision, dist_lat double precision, dist_long double precision);

drop function if exists "public"."pubs_in_polygon"(geojson text, dist_long double precision, dist_lat double precision);

drop function if exists "public"."saved_pubs"(dist_long double precision, dist_lat double precision);

create table "public"."review_helpfuls" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "user_id" uuid not null default auth.uid(),
    "review_id" bigint not null,
    "is_helpful" boolean not null
);


alter table "public"."review_helpfuls" enable row level security;

create table "public"."rls_table" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "test_table_a_id" bigint,
    "test_table_b_id" bigint
);


alter table "public"."rls_table" enable row level security;

alter table "public"."reviews" alter column "content" set data type text using "content"::text;

CREATE UNIQUE INDEX review_helpfuls_pkey ON public.review_helpfuls USING btree (id);

CREATE UNIQUE INDEX review_helpfuls_user_id_review_id_key ON public.review_helpfuls USING btree (user_id, review_id);

CREATE UNIQUE INDEX reviews_pub_id_user_id_key ON public.reviews USING btree (pub_id, user_id);

CREATE UNIQUE INDEX rls_table_pkey ON public.rls_table USING btree (id);

alter table "public"."review_helpfuls" add constraint "review_helpfuls_pkey" PRIMARY KEY using index "review_helpfuls_pkey";

alter table "public"."rls_table" add constraint "rls_table_pkey" PRIMARY KEY using index "rls_table_pkey";

alter table "public"."review_helpfuls" add constraint "review_helpfuls_review_id_fkey" FOREIGN KEY (review_id) REFERENCES reviews(id) not valid;

alter table "public"."review_helpfuls" validate constraint "review_helpfuls_review_id_fkey";

alter table "public"."review_helpfuls" add constraint "review_helpfuls_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."review_helpfuls" validate constraint "review_helpfuls_user_id_fkey";

alter table "public"."review_helpfuls" add constraint "review_helpfuls_user_id_review_id_key" UNIQUE using index "review_helpfuls_user_id_review_id_key";

alter table "public"."reviews" add constraint "reviews_pub_id_user_id_key" UNIQUE using index "reviews_pub_id_user_id_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_pub(input_id integer, dist_long double precision, dist_lat double precision)
 RETURNS TABLE(id integer, google_rating real, name text, address text, phone_number text, google_overview text, google_ratings_amount integer, reservable boolean, website text, dog_friendly boolean, live_sport boolean, pool_table boolean, dart_board boolean, beer_garden boolean, kid_friendly boolean, free_wifi boolean, rooftop boolean, foosball_table boolean, wheelchair_accessible boolean, photos text[], opening_hours jsonb, location text, dist_meters double precision, review_vibe double precision, review_beer double precision, review_music double precision, review_service double precision, review_location double precision, review_food double precision, num_reviews integer, saved boolean, google_id text)
 LANGUAGE sql
AS $function$
select
    p.id,
    p.google_rating,
    p.name,
    p.address,
    p.phone_number,
    p.google_overview,
    p.google_ratings_amount,
    p.reservable,
    p.website,
    p.dog_friendly,
    p.live_sport,
    p.pool_table,
    p.dart_board,
    p.beer_garden,
    p.kid_friendly,
    p.free_wifi,
    p.rooftop,
    p.foosball_table,
    p.wheelchair_accessible,
    array_remove(array_agg(distinct pp.key), NULL) as photos,
    json_agg(distinct oh) as opening_hours,
    st_asgeojson(p.location) as location,
    st_distance(
        p.location,
        st_point(dist_long, dist_lat) :: geography
    ) as dist_meters,
    avg(r.vibe) as review_vibe,
    avg(r.beer) as review_beer,
    avg(r.music) as review_music,
    avg(r.service) as review_service,
    avg(r.location) as review_location,
    avg(r.food) as review_food,
    count(distinct r) as num_reviews,
    count(
        s.pub_id = p.id
        and s.user_id = auth.uid()
    ) > 0 as saved,
    p.google_id
from
    public.pubs p
    left join public.saves s on p.id = s.pub_id
    left join pub_photos pp on pp.pub_id = p.id
    left join opening_hours oh on p.id = oh.pub_id
    left join public.reviews r on p.id = r.pub_id
where
    p.id = input_id
group by
    p.id $function$
;

CREATE OR REPLACE FUNCTION public.nearby_pubs(order_lat double precision, order_long double precision, dist_lat double precision, dist_long double precision)
 RETURNS TABLE(id integer, google_rating real, name text, address text, phone_number text, google_overview text, google_ratings_amount integer, reservable boolean, website text, dog_friendly boolean, live_sport boolean, pool_table boolean, dart_board boolean, beer_garden boolean, kid_friendly boolean, free_wifi boolean, rooftop boolean, foosball_table boolean, wheelchair_accessible boolean, location text, dist_meters double precision, photos text[], opening_hours json, saved boolean, review_vibe double precision, review_beer double precision, review_music double precision, review_service double precision, review_location double precision, review_food double precision, num_reviews integer, google_id text)
 LANGUAGE sql
AS $function$
select
    p.id,
    p.google_rating,
    p.name,
    p.address,
    p.phone_number,
    p.google_overview,
    p.google_ratings_amount,
    p.reservable,
    p.website,
    p.dog_friendly,
    p.live_sport,
    p.pool_table,
    p.dart_board,
    p.beer_garden,
    p.kid_friendly,
    p.free_wifi,
    p.rooftop,
    p.foosball_table,
    p.wheelchair_accessible,
    st_asgeojson(p.location) as location,
    st_distance(
        p.location,
        st_point(dist_long, dist_lat) :: geography
    ) as dist_meters,
    array_remove(array_agg(distinct pp.key), NULL) as photos,
    json_agg(distinct oh) as opening_hours,
    count(
        s.pub_id = p.id
        and s.user_id = auth.uid()
    ) > 0 as saved,
    avg(r.vibe) as review_vibe,
    avg(r.beer) as review_beer,
    avg(r.music) as review_music,
    avg(r.service) as review_service,
    avg(r.location) as review_location,
    avg(r.food) as review_food,
    count(distinct r) as num_reviews,
    p.google_id
from
    public.pubs p
    left join public.saves s on p.id = s.pub_id
    left join pub_photos pp on pp.pub_id = p.id
    left join opening_hours oh on p.id = oh.pub_id
    left join public.reviews r on p.id = r.pub_id
group by
    p.id
order by
    p.location <-> st_point(order_long, order_lat) :: geography;

$function$
;

CREATE OR REPLACE FUNCTION public.pubs_in_polygon(geojson text, dist_long double precision, dist_lat double precision)
 RETURNS TABLE(id integer, google_rating real, name text, address text, phone_number text, google_overview text, google_ratings_amount integer, reservable boolean, website text, dog_friendly boolean, live_sport boolean, pool_table boolean, dart_board boolean, beer_garden boolean, kid_friendly boolean, free_wifi boolean, rooftop boolean, foosball_table boolean, wheelchair_accessible boolean, location text, dist_meters double precision, photos text[], opening_hours json, saved boolean, review_vibe double precision, review_beer double precision, review_music double precision, review_service double precision, review_location double precision, review_food double precision, num_reviews integer, google_id text)
 LANGUAGE sql
AS $function$
select
	p.id,
	p.google_rating,
	p.name,
	p.address,
	p.phone_number,
	p.google_overview,
	p.google_ratings_amount,
	p.reservable,
	p.website,
	p.dog_friendly,
	p.live_sport,
	p.pool_table,
	p.dart_board,
	p.beer_garden,
	p.kid_friendly,
	p.free_wifi,
	p.rooftop,
	p.foosball_table,
	p.wheelchair_accessible,
	st_asgeojson(p.location) as location,
	st_distance(
		p.location,
		st_point(dist_long, dist_lat) :: geography
	) as dist_meters,
	array_remove(array_agg(distinct pp.key), NULL) as photos,
	json_agg(distinct oh) as opening_hours,
	count(
		s.pub_id = p.id
		and s.user_id = auth.uid()
	) > 0 as saved,
	avg(r.vibe) as review_vibe,
	avg(r.beer) as review_beer,
	avg(r.music) as review_music,
	avg(r.service) as review_service,
	avg(r.location) as review_location,
	avg(r.food) as review_food,
	count(distinct r) as num_reviews,
	p.google_id
from
	public.pubs p
	left join public.saves s on p.id = s.pub_id
	left join pub_photos pp on pp.pub_id = p.id
	left join opening_hours oh on p.id = oh.pub_id
	left join reviews r on p.id = r.pub_id
where
	ST_Within(
		p.location :: geometry,
		ST_GeomFromGeoJSON(geojson)
	)
group by
	p.id $function$
;

CREATE OR REPLACE FUNCTION public.saved_pubs(dist_long double precision, dist_lat double precision)
 RETURNS TABLE(id integer, created_at timestamp with time zone, google_rating real, name text, address text, phone_number text, google_overview text, google_ratings_amount integer, reservable boolean, website text, dog_friendly boolean, live_sport boolean, pool_table boolean, dart_board boolean, beer_garden boolean, kid_friendly boolean, free_wifi boolean, rooftop boolean, foosball_table boolean, wheelchair_accessible boolean, photos text[], opening_hours jsonb, location text, dist_meters double precision, review_vibe double precision, review_beer double precision, review_music double precision, review_service double precision, review_location double precision, review_food double precision, num_reviews integer, saved boolean, google_id text)
 LANGUAGE sql
AS $function$
select
    p.id,
    s.created_at,
    p.google_rating,
    p.name,
    p.address,
    p.phone_number,
    p.google_overview,
    p.google_ratings_amount,
    p.reservable,
    p.website,
    p.dog_friendly,
    p.live_sport,
    p.pool_table,
    p.dart_board,
    p.beer_garden,
    p.kid_friendly,
    p.free_wifi,
    p.rooftop,
    p.foosball_table,
    p.wheelchair_accessible,
    array_remove(array_agg(distinct pp.key), NULL) as photos,
    json_agg(distinct oh) as opening_hours,
    st_asgeojson(p.location) as location,
    st_distance(
        p.location,
        st_point(dist_long, dist_lat) :: geography
    ) as dist_meters,
    avg(r.vibe) as review_vibe,
    avg(r.beer) as review_beer,
    avg(r.music) as review_music,
    avg(r.service) as review_service,
    avg(r.location) as review_location,
    avg(r.food) as review_food,
    count(distinct r) as num_reviews,
    true as saved,
    p.google_id
from
    public.pubs p
    join public.saves s on p.id = s.pub_id
    left join pub_photos pp on pp.pub_id = p.id
    join opening_hours oh on p.id = oh.pub_id
    left join reviews r on p.id = r.pub_id
where
    s.user_id = auth.uid()
group by
    p.id,
    s.id $function$
;

create policy "another test"
on "public"."review_helpfuls"
as permissive
for insert
to public
with check (true);


create policy "blah"
on "public"."review_helpfuls"
as permissive
for all
to public
using (true)
with check (true);


create policy "test 234"
on "public"."review_helpfuls"
as permissive
for update
to public
using (true)
with check (true);


create policy "authenticated users can create reviews"
on "public"."reviews"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "ensure unique values"
on "public"."rls_table"
as permissive
for insert
to public
with check ((NOT (EXISTS ( SELECT 1
   FROM rls_table rls
  WHERE (rls_table.test_table_a_id = rls.test_table_a_id)))));



