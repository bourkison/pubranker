drop view if exists "public"."formatted_pubs";

create table "public"."comment_likes" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "comment_id" bigint not null,
    "user_id" uuid not null default auth.uid()
);


alter table "public"."comment_likes" enable row level security;

alter table "public"."pub_schema" add column "overall_reviews" double precision not null;

CREATE UNIQUE INDEX comment_likes_pkey ON public.comment_likes USING btree (id);

CREATE UNIQUE INDEX comment_likes_user_id_comment_id_key ON public.comment_likes USING btree (user_id, comment_id);

alter table "public"."comment_likes" add constraint "comment_likes_pkey" PRIMARY KEY using index "comment_likes_pkey";

alter table "public"."comment_likes" add constraint "comment_likes_comment_id_fkey" FOREIGN KEY (comment_id) REFERENCES comments(id) not valid;

alter table "public"."comment_likes" validate constraint "comment_likes_comment_id_fkey";

alter table "public"."comment_likes" add constraint "comment_likes_user_id_comment_id_key" UNIQUE using index "comment_likes_user_id_comment_id_key";

alter table "public"."comment_likes" add constraint "comment_likes_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."comment_likes" validate constraint "comment_likes_user_id_fkey";

set check_function_bodies = off;

create or replace view "public"."formatted_pubs" as  SELECT p.id,
    p.google_rating,
    p.name,
    p.address,
    p.phone_number,
    p.google_overview,
    p.google_ratings_amount,
    p.reservable,
    p.website,
    p.dog_friendly,
    p.live_sport,
    p.pool_table,
    p.dart_board,
    p.beer_garden,
    p.kid_friendly,
    p.free_wifi,
    p.rooftop,
    p.foosball_table,
    p.wheelchair_accessible,
    array_remove(array_agg(DISTINCT pp.key), NULL::text) AS photos,
    json_agg(DISTINCT oh.*) AS opening_hours,
    st_asgeojson(p.location) AS location,
    COALESCE(avg(r.vibe), (0)::double precision) AS review_vibe,
    COALESCE(avg(r.beer), (0)::double precision) AS review_beer,
    COALESCE(avg(r.music), (0)::double precision) AS review_music,
    COALESCE(avg(r.service), (0)::double precision) AS review_service,
    COALESCE(avg(r.location), (0)::double precision) AS review_location,
    COALESCE(avg(r.food), (0)::double precision) AS review_food,
    ( SELECT avg(t.c) AS avg
           FROM ( VALUES (COALESCE(avg(r.vibe), (0)::double precision)), (COALESCE(avg(r.beer), (0)::double precision)), (COALESCE(avg(r.music), (0)::double precision)), (COALESCE(avg(r.service), (0)::double precision)), (COALESCE(avg(r.location), (0)::double precision)), (COALESCE(avg(r.food), (0)::double precision))) t(c)) AS overall_reviews,
    COALESCE(count(DISTINCT r.*), (0)::bigint) AS num_reviews,
    (count(((s.pub_id = p.id) AND (s.user_id = auth.uid()))) > 0) AS saved,
    p.google_id
   FROM ((((pubs p
     LEFT JOIN saves s ON ((p.id = s.pub_id)))
     LEFT JOIN pub_photos pp ON ((pp.pub_id = p.id)))
     LEFT JOIN opening_hours oh ON ((p.id = oh.pub_id)))
     LEFT JOIN reviews r ON ((p.id = r.pub_id)))
  GROUP BY p.id;


CREATE OR REPLACE FUNCTION public.nearby_pubs(order_lat double precision, order_long double precision, dist_lat double precision, dist_long double precision)
 RETURNS SETOF pub_schema
 LANGUAGE sql
AS $function$
select
    p.id,
	p.google_rating,
	p.name,
	p.address,
	p.phone_number,
	p.google_overview,
	p.google_ratings_amount,
	p.reservable,
	p.website,
	p.dog_friendly,
	p.live_sport,
	p.pool_table,
	p.dart_board,
	p.beer_garden,
	p.kid_friendly,
	p.free_wifi,
	p.rooftop,
	p.foosball_table,
	p.wheelchair_accessible,
	p.photos,
	p.opening_hours,
	p.location,
	p.review_vibe,
	p.review_beer,
	p.review_music,
	p.review_service,
	p.review_location,
	p.review_food,
	p.num_reviews,
	p.saved,
	p.google_id,
    st_distance(
        st_GeomFromGeoJSON(p.location),
        st_point(dist_long, dist_lat) :: geography
    ) as dist_meters,
	p.overall_reviews as overall_reviews
from
    public.formatted_pubs p
order by
    st_GeomFromGeoJSON(p.location) <-> st_point(order_long, order_lat) :: geography;

$function$
;

create or replace view "public"."user_comments" as  SELECT c.id,
    c.created_at,
    c.updated_at,
    c.content,
    c.user_id,
    c.review_id,
    u.name AS user_name,
    count(DISTINCT l.*) AS likes_amount,
    (count(((l.comment_id = c.id) AND (c.user_id = auth.uid()))) > 0) AS liked
   FROM ((comments c
     LEFT JOIN users_public u ON ((u.id = c.user_id)))
     LEFT JOIN comment_likes l ON ((l.comment_id = c.id)))
  GROUP BY c.id, u.id;


create policy "all users can pull likes"
on "public"."comment_likes"
as permissive
for select
to public
using (true);


create policy "users can create their own likes"
on "public"."comment_likes"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "users can delete their own likes"
on "public"."comment_likes"
as permissive
for delete
to public
using ((auth.uid() = user_id));



